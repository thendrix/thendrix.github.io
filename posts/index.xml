<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Thoughts on GameDev</title>
        <link>/posts/</link>
        <description>Recent content in Posts on Thoughts on GameDev</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sat, 28 Mar 2020 00:00:00 +0000</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Welcome</title>
            <link>/posts/2020/03/welcome/</link>
            <pubDate>Sat, 28 Mar 2020 00:00:00 +0000</pubDate>
            
            <guid>/posts/2020/03/welcome/</guid>
            <description>Testing out using hugo for blogging. I was going to bring over some old blog posts to here, but decided it might be better to update those posts and roll them out later.
Today I&amp;rsquo;ll just link to the video of the transient material instance (MI) system that was put in not long ago. This system allows every object to have it&amp;rsquo;s own procedurally generated MI to handle various parameters of VFX materials such as volume, colors, patterns.</description>
            <content type="html"><![CDATA[<p>Testing out using hugo for blogging.  I was going to bring over some old blog posts to here, but decided it might be better to update those posts and roll them out later.</p>
<p>Today I&rsquo;ll just link to the video of the transient material instance (MI) system that was put in not long ago.  This system allows every object to have it&rsquo;s own procedurally generated MI to handle various parameters of VFX materials such as volume, colors, patterns.  All of the fluids in the video are using the same shader/material.</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/eRahBAfaHWA" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

]]></content>
        </item>
        
        <item>
            <title>Noise!</title>
            <link>/posts/2016/01/noise/</link>
            <pubDate>Sat, 30 Jan 2016 00:00:00 +0000</pubDate>
            
            <guid>/posts/2016/01/noise/</guid>
            <description>Update: Screenshots with realistic sized trees on same terrain, and fixed some links. :3
 Tree scale now in 10-20m range
 Tree scale now in 10-20m range
I noticed r/proceduralgeneration has a lot activity lately, so I thought I would do quick post on how I&amp;rsquo;m generating my current test islands with only 4 functions. This is what they typically look like:
 Terrain generated by simple density function</description>
            <content type="html"><![CDATA[<p><strong>Update</strong>: Screenshots with realistic sized trees on same terrain, and fixed some links.  :3</p>
<p><a href="/images/20160130/kagura-0.15.0-20160204-175819-0000.png"><img src="/images/20160130/kagura-0.15.0-20160204-175819-0000.png" alt="gallery" title="Tree scale now in 10-20m range"></a>
<em>Tree scale now in 10-20m range</em></p>
<p><a href="/images/20160130/kagura-0.15.0-20160204-182246-0000.png"><img src="/images/20160130/kagura-0.15.0-20160204-182246-0000.png" alt="gallery" title="Tree scale now in 10-20m range"></a>
<em>Tree scale now in 10-20m range</em></p>
<p>I noticed <a href="https://www.reddit.com/r/proceduralgeneration">r/proceduralgeneration</a> has a lot activity lately, so I thought I would do quick post on how I&rsquo;m generating my current test islands with only 4 functions.  This is what they typically look like:</p>
<p><a href="/images/20160130/kagura-0.15.0-20160130-002137-0000.png"><img src="/images/20160130/kagura-0.15.0-20160130-002137-0000.png" alt="gallery" title="Terrain generated by simple density function"></a>
<em>Terrain generated by simple density function</em></p>
<h2 id="terrian-geometry">Terrian Geometry</h2>
<p>I basically use both 2d and 3d simplex noise to add and subtract a global density function, which is described per terrain cube.  You can stack cubes like octrees, or more typically just a simple XZ grid.  This density function is used to produce voxels, which are then in turn converted to meshes for physics and rendering.  I don&rsquo;t use GPU rendering of the voxels as I need that GPU time for VR.  :3</p>
<p>All of this is done in realtime via the clever use of worker threads with the option to serialize them out as models.  Each cube is typically 256 meters.  Yes, this means if you want really tall mountains you need to stack another layer of cubes on top of your XZ grid.</p>
<p>This listing shows how I build the density function to pass into a now obsolete KaMeshComponent, which will then in turn start deferred creation of the meshes for physics and rendering.  The above island is solely defined as as the global density function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">local</span> density <span style="color:#f92672">=</span> KaDensity.Create()
KaDensity.Seed( density, <span style="color:#ae81ff">2312.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">561.972</span> )
KaDensity.AddFractalNoise2d( density, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">32.0</span>, <span style="color:#ae81ff">8.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">32.0</span> )
KaDensity.AddFractalNoise2d( density, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">8.0</span>, <span style="color:#ae81ff">8.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">8.0</span> )
KaDensity.SubFractalNoise2d( density, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">64.0</span>, <span style="color:#ae81ff">8.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">6.0</span> )
KaDensity.AddFractalNoise3d( density, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">32.0</span>, <span style="color:#ae81ff">4.5</span> )
</code></pre></div><p><em>listing 1</em></p>
<p>Notice there is little use of 3d, as that is more for making hills, caves, rivers, and arches.  Also you could introduce local density for features, but I don&rsquo;t typically do any manual level editing at this point in project.  This is one of my small islands used for testing materials.</p>
<h2 id="terrian-material">Terrian Material</h2>
<p>The terrain is composed from a simple triplanar shader.  World height, world slope, and a per pixel Fractal Brownian Motion ( FBM ) to break up the monotony of ground foliage.  There are typically beach sand, dirt, grass ( eg green to brown / height ), and stone generated from this step.  Since you can modify shaders at runtime in kagura this can be fun to improve when you have a few extra minutes in the day.</p>
<h2 id="terrian-foliage">Terrian Foliage</h2>
<p>Once terrain geometry is instanced it will be filled with large vegetation and deco such as bushes and trees to rocks and statues.  For every XY terrain sector I generate a SpawnTracer.  The spawner will &lsquo;ping&rsquo; for the worker threads to be done by ray casting for terrain to appear in its given sector.  Once this is done it issues the given spawn callback.  In this case the callback is a per sector foliage trace driven again by a grid pattern filtered by a tillable FBM ( see <a href="/posts/2015/12/screenshot-weekend/">old blog post</a> ), slope, height, max per tile count of an object type, and a few other attributes.  This pass handles the case where a house is placed on terrain for example, so it would not put trees and grass on top of it.  It is important to note these happen out of order, and the tiling pattern provided by the FBM is the trick making smooth transitions between tiles possible.</p>
<p><a href="/images/20160130/kagura-0.15.0-20160130-123928-0000.png"><img src="/images/20160130/kagura-0.15.0-20160130-123928-0000.png" alt="gallery" title="Closer look at the same scene"></a>
<em>Closer look at the same scene</em></p>
<p>That&rsquo;s basically how the system works, and it&rsquo;s a little more complex than that but not much.  I&rsquo;d be happy to answer any questions or take comments.  Here&rsquo;s a script function that creates the entire island above:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lua" data-lang="lua"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">VoxelTerrainComponent</span>.<span style="color:#a6e22e">OnCreate</span>( self )
	<span style="color:#66d9ef">local</span> sz <span style="color:#f92672">=</span> self.width
	<span style="color:#66d9ef">local</span> hsz <span style="color:#f92672">=</span> self.height
	<span style="color:#66d9ef">local</span> scale <span style="color:#f92672">=</span> <span style="color:#ae81ff">256.0</span>

	<span style="color:#66d9ef">local</span> density <span style="color:#f92672">=</span> KaDensity.Create()
	KaDensity.Seed( density, <span style="color:#ae81ff">2312.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">561.972</span> )
	KaDensity.AddFractalNoise2d( density, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">32.0</span>, <span style="color:#ae81ff">8.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">32.0</span> )
	KaDensity.AddFractalNoise2d( density, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">8.0</span>, <span style="color:#ae81ff">8.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">8.0</span> )
	KaDensity.SubFractalNoise2d( density, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">64.0</span>, <span style="color:#ae81ff">8.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">6.0</span> )
	KaDensity.AddFractalNoise3d( density, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">32.0</span>, <span style="color:#ae81ff">4.5</span> )

	<span style="color:#66d9ef">for</span> x <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>sz, sz <span style="color:#66d9ef">do</span>
	<span style="color:#66d9ef">for</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, hsz <span style="color:#66d9ef">do</span>
	<span style="color:#66d9ef">for</span> z <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>sz, sz <span style="color:#66d9ef">do</span>
		<span style="color:#66d9ef">local</span> name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;VoxelMesh_&#34;</span> <span style="color:#f92672">..</span> x <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;_&#34;</span> <span style="color:#f92672">..</span> y <span style="color:#f92672">..</span> <span style="color:#e6db74">&#34;_&#34;</span> <span style="color:#f92672">..</span> z
		<span style="color:#66d9ef">local</span> dump <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Cache/&#39;</span> <span style="color:#f92672">..</span> name <span style="color:#f92672">..</span> <span style="color:#e6db74">&#39;.asset&#39;</span>
		<span style="color:#66d9ef">local</span> sector <span style="color:#f92672">=</span> KaGameObject.New( x <span style="color:#f92672">*</span> scale, y <span style="color:#f92672">*</span> scale, z <span style="color:#f92672">*</span> scale )
		KaGameObject.SetName( sector, name )
		KaMeshComponent.CreateFromVoxels(sector, density, dump, self.material, x,y,z)
		KaGameObject.Finalize( sector )
		KaGameObject.Hide( sector )
		KaGameObject.AddChild( self._GameObject, sector )

		<span style="color:#66d9ef">if</span> self.foliage <span style="color:#f92672">and</span> y <span style="color:#f92672">==</span> <span style="color:#ae81ff">0.0</span> <span style="color:#66d9ef">then</span>
			<span style="color:#75715e">-- Place spawners and mappers in the middle of the voxel sector.</span>
			<span style="color:#66d9ef">local</span> offset <span style="color:#f92672">=</span> scale <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.5</span>
			SpawnByTracePrefabChild( <span style="color:#e6db74">&#34;FoliageSpawner&#34;</span>, self._GameObject,
					x <span style="color:#f92672">*</span> scale <span style="color:#f92672">+</span> offset,
					y <span style="color:#f92672">*</span> scale <span style="color:#f92672">+</span> scale <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.75</span>,
					z <span style="color:#f92672">*</span> scale <span style="color:#f92672">+</span> offset,
					<span style="color:#75715e">-- VoxelSectorFoliageCb )</span>
					VoxelSectorFoliageFbmCb )
		<span style="color:#66d9ef">end</span>
	<span style="color:#66d9ef">end</span>
	<span style="color:#66d9ef">end</span>
	<span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>
</code></pre></div><p><em>listing 2</em></p>
<p>And here&rsquo;s what you can do with unfiltered 3d noise:</p>
<p><a href="/images/20160130/kagura-0.15.0-20160128-170004-0000.png"><img src="/images/20160130/kagura-0.15.0-20160128-170004-0000.png" alt="gallery" title="Terrain Generated from Unfiltered 3d Noise"></a>
<em>Terrain Generated from Unfiltered 3d Noise</em></p>
]]></content>
        </item>
        
        <item>
            <title>Screenshot Weekend</title>
            <link>/posts/2015/12/screenshot-weekend/</link>
            <pubDate>Sun, 27 Dec 2015 00:00:00 +0000</pubDate>
            
            <guid>/posts/2015/12/screenshot-weekend/</guid>
            <description>Well, mostly focused on non-renderer stuff this weekend like bringing more of the web editor interface into in-game viewport UI. A few minor improvements to sky with a simple per fragment Preetham, and ported all my shaders to the updated Kagura shader lang to get ready for Vulkan.
 screenshot 1
Same scene &amp;ndash; different foliage seed &amp;ndash; with some general lighting improvements:
 screenshot 2
 screenshot 3
 screenshot 4</description>
            <content type="html"><![CDATA[<p>Well, mostly focused on non-renderer stuff this weekend like bringing more of the web editor interface into in-game viewport UI.  A few minor improvements to sky with a simple per fragment Preetham, and ported all my shaders to the updated Kagura shader lang to get ready for Vulkan.</p>
<p><a href="/images/20151227/kagura-0.15.0-20151227-002612-0000.png"><img src="/images/20151227/kagura-0.15.0-20151227-002612-0000.png" alt="gallery" title="screenshot 1"></a>
<em>screenshot 1</em></p>
<p>Same scene &ndash; different foliage seed &ndash; with some general lighting improvements:</p>
<p><a href="/images/20151227/kagura-0.15.0-20151227-212851-0000.png"><img src="/images/20151227/kagura-0.15.0-20151227-212851-0000.png" alt="gallery" title="screenshot 2"></a>
<em>screenshot 2</em></p>
<p><a href="/images/20151227/kagura-0.15.0-20151227-211937-0000.png"><img src="/images/20151227/kagura-0.15.0-20151227-211937-0000.png" alt="gallery" title="screenshot 3"></a>
<em>screenshot 3</em></p>
<p><a href="/images/20151227/kagura-0.15.0-20151227-002612-0000.png"><img src="/images/20151227/kagura-0.15.0-20151227-002612-0000.png" alt="gallery" title="screenshot 4"></a>
<em>screenshot 4</em></p>
<p>Below is a simple test for tiling fbm independently for foliage generation with the threaded voxel sectors, so there is no need to do another physics based ray cast pass.  Each pixel is 0.5m^2 per sector here.  Basically this is using a multi-level frequency hierarchy to generate the foliage overlays independent of other tiles, yet still match up.  I might try to expand this to 3d vol tiles for things like clouds for proc sky + ray marching later.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">KaNoiseFractalBrownianMotion2d(octaves,
    (x <span style="color:#f92672">+</span> tx <span style="color:#f92672">*</span> <span style="color:#ae81ff">512.0f</span>) <span style="color:#f92672">*</span> frequency,
    (z <span style="color:#f92672">+</span> tz <span style="color:#f92672">*</span> <span style="color:#ae81ff">512.0f</span>) <span style="color:#f92672">*</span> frequency,
    amplitude, lacunarity, gain);
</code></pre></div><p><a href="/images/20151227/screenshot-area-2015-12-27-112646.png"><img src="/images/20151227/screenshot-area-2015-12-27-112646.png" alt="gallery" title="noise tiles"></a>
<em>noise tiles</em></p>
<p><a href="/images/20151227/screenshot-area-2015-12-27-112700.png"><img src="/images/20151227/screenshot-area-2015-12-27-112700.png" alt="gallery" title="noise tiles combined"></a>
<em>noise tiles combined</em></p>
]]></content>
        </item>
        
        <item>
            <title>Ugly Terrain</title>
            <link>/posts/2014/07/ugly-terrain/</link>
            <pubDate>Mon, 28 Jul 2014 00:00:00 +0000</pubDate>
            
            <guid>/posts/2014/07/ugly-terrain/</guid>
            <description>Getting tired of pure voxel terrain again, so I&amp;rsquo;m going to move voxel system to more of a detail terrain painting system. GPU Clipmaps are cool again, and much more flexible when it comes to foliage deco &amp;ndash; so hopefully this will be the last ugly terrain screenshot. Making the system to generate foliage with raycasts as seen in ye old island demo as fun for programmer art, however for deco painting artists don&amp;rsquo;t like that kind of thing.</description>
            <content type="html"><![CDATA[<p>Getting tired of pure voxel terrain again, so I&rsquo;m going to move voxel system to more of a detail terrain painting system.  GPU Clipmaps are cool again, and much more flexible when it comes to foliage deco &ndash; so hopefully this will be the last ugly terrain screenshot.  Making the system to generate foliage with raycasts as seen in ye old island demo as fun for programmer art, however for deco painting artists don&rsquo;t like that kind of thing.   ;)</p>
<p><a href="/images/20140728/kagura-14.3.16-0098.png"><img src="/images/20140728/kagura-14.3.16-0098.png" alt="gallery" title="Terrain with Triplanar Material"></a>
<strong>Terrain with Triplanar Material</strong></p>
<p><a href="/images/20140728/kagura-14.3.16-0105.png"><img src="/images/20140728/kagura-14.3.16-0105.png" alt="gallery" title="Terrain with Procedural Placement and Materials"></a>
<strong>Procedural Placement and Materials</strong></p>
]]></content>
        </item>
        
        <item>
            <title>Terrain and Biomes and Flora oh my</title>
            <link>/posts/2013/10/terrain-and-biomes-and-flora-oh-my/</link>
            <pubDate>Mon, 07 Oct 2013 00:00:00 +0000</pubDate>
            
            <guid>/posts/2013/10/terrain-and-biomes-and-flora-oh-my/</guid>
            <description>So I dusted off the terrain / biome system to hook it up to the voxel terrain system, since it makes a lot more sense to model very large landmasses in a way people can understand. Density functions by parts isn&amp;rsquo;t a bad thing, but even if you expose this with a UI flow graph &amp;ndash; who the fuck is going to understand it that also wants to use a flow graph chart?</description>
            <content type="html"><![CDATA[<p>So I dusted off the terrain / biome system to hook it up to the voxel terrain system, since it makes a lot more sense to model very large landmasses in a way people can understand.  Density functions by parts isn&rsquo;t a bad thing, but even if you expose this with a UI flow graph &ndash; who the fuck is going to understand it that also wants to use a flow graph chart?  Exactly.</p>
<p>Better to allow for &lsquo;big picture&rsquo; visualization of what those damn things do I say.  Take for example this simple gem on how to generate large landmasses&hellip; Clamp your density by masks of large water bodies and scale by smaller ones.  Simple and effective.  Rock composition is the variable that effects water erosion the most.  It happens in nature everywhere that&rsquo;s why you get the grand canyon to the salt flats.  Forget elevation as the main factor.</p>
<p>In fact you can completely ignore the physics and go for a purely artistic version of a bay like below.  Only using three of the density function operators no less for a playground for artists to start hacking away.  Each KaDensity function takes a list of parameters and returns a density.  They&rsquo;re pretty self-explanatory:</p>
<pre><code>KaDensityNoiseSimplex2d : octaves, frequency, lacunarity, gain
KaDensitySaturate : density
KaDensityMul : density_A, density_B
</code></pre><p>Here each stage is generated via simplex noise and saturated to threshold the values, and then combined to produce composite images.  Don&rsquo;t have to teach artists about physics or generate all the voxel terrain for them to visualize while dialing it in&hellip;  make continent iteration quicker.  This mask alone has a large effect on the Terrain and Biomes as you can see.  From here you can pass this to VoxelSector density samplers and get your 3d terrain as a GPU visualization and / or CPU mesh from isosurface extraction as seen previously on the blog.  BTW I have found the ideal width of a river is ~1km so these pixels are about 1km^2 while typically I would generate VoxelSectors at about 1/4km^3 to give a sense of scale.  That makes these preview windows about 512x512km while the camera in game tends to only go to a view distance of 12km.  From here you can feed back masks into each other such as for Fanua mask generator.  :)</p>
<p><a href="/images/20131007/water-mask.png"><img src="/images/20131007/water-mask.png" alt="gallery" title="Generating Water Mask"></a>
<strong>Generating Water Mask</strong></p>
<p><a href="/images/20131007/biome.png"><img src="/images/20131007/biome.png" alt="gallery" title="Terrain + Biomes Visualization"></a>
<strong>Terrain + Biomes Visualization</strong></p>
<p><a href="/images/20131007/layer-flora.png"><img src="/images/20131007/layer-flora.png" alt="gallery" title="Flora Visualization"></a>
<strong>Flora Visualization</strong></p>
]]></content>
        </item>
        
        <item>
            <title>Voxel Terrain Sector Preview</title>
            <link>/posts/2013/09/voxel-terrain-sector-preview/</link>
            <pubDate>Mon, 09 Sep 2013 00:00:00 +0000</pubDate>
            
            <guid>/posts/2013/09/voxel-terrain-sector-preview/</guid>
            <description>Got the basic voxel terrain in today. The most time was spent on new ways to generate and enqueue Voxels, RenderMesh, PhysicsMesh in various worker threads and sync them amongst all the subsystems. Also refactored some of the math library and noise generation while in there to avoid overlap.
 Voxel Terrain Sectors 2x1x2
The scale of this image required me to adjust my camera&amp;hellip; typical player could be about as big as a pixel here&amp;hellip; going to hook this up to my biome and erosion simulation next.</description>
            <content type="html"><![CDATA[<p>Got the basic voxel terrain in today.  The most time was spent on new ways to generate and enqueue Voxels, RenderMesh, PhysicsMesh in various worker threads and sync them amongst all the subsystems.  Also refactored some of the math library and noise generation while in there to avoid overlap.</p>
<p><a href="/images/20130909/kagura-0.5.4-0657.png"><img src="/images/20130909/kagura-0.5.4-0657.png" alt="gallery" title="Voxel Terrain Sectors 2x1x2"></a>
<strong>Voxel Terrain Sectors 2x1x2</strong></p>
<p>The scale of this image required me to adjust my camera&hellip; typical player could be about as big as a pixel here&hellip; going to hook this up to my biome and erosion simulation next.  That way flora and fauna will spawn with rivers and &lsquo;set piece&rsquo; locations, and have some more high frequency details&hellip; I had some crazy stuff like ocean trenches prototyped, but who would ever see that?  Took out the randomized caves for now too as they should be created by the biome / erosion system.  The trick will be to convert it to density functions properly - eg account for overlapping terrain.  I don&rsquo;t think trees grow under ground.</p>
<p>This is just a 2x1x2 voxel terrain patch to get a sense of scale&hellip; I have mostly been testing with 6x2x6 and 9x3x9 for a complete world earlier.  It is all hooked up to script you can spawn more terrain as the player runs around until you run out of floating point sanity if you like.</p>
<p>Memory overhead is super low at ~1/4 the size of the older heightmap generated terrain.  That said you could make worlds smaller than one walk cycle of animation or short sound clip by far still.  :D</p>
<p>Planning on adding real-time editor later that works by altering density in a selected Voxel Sector for artist controlled editing via terrain brush.  It would be nice to make it work with touchscreens via the web editor too in real-time, but not high on my list.  Elevation and Biome splat controller needs to come in next.  Maybe add some slope blending adjustments to the basic shader / materials too.</p>
<p>The most fun will be allowing scripted density functions by exposing the native structs holding function pointers and args to script that run in the density summation as addends.  In other words alter the density functions from script ( data driven ) at any time not just alter the voxel field&hellip; well laters.</p>
]]></content>
        </item>
        
        <item>
            <title>Isosurface Extraction done quick</title>
            <link>/posts/2013/09/isosurface-extraction-done-quick/</link>
            <pubDate>Sat, 07 Sep 2013 00:00:00 +0000</pubDate>
            
            <guid>/posts/2013/09/isosurface-extraction-done-quick/</guid>
            <description>Cross post from Google+:
Voxels and Triplanar Mapping only took a day and a half thanks to the excellent docs from Nvidia and my awesome little engine that could. Going to work in real-time editing and maybe tessellation guided by isosurface extraction later if I don&amp;rsquo;t get sidetracked with other big features. This is a CPU converted isosurface to standard mesh to use the CPU side physics. eg voxels -&amp;gt; mesh.</description>
            <content type="html"><![CDATA[<p>Cross post from Google+:</p>
<p>Voxels and Triplanar Mapping only took a day and a half thanks to the excellent docs from Nvidia and my awesome little engine that could. Going to work in real-time editing and maybe tessellation guided by isosurface extraction later if I don&rsquo;t get sidetracked with other big features. This is a CPU converted isosurface to standard mesh to use the CPU side physics. eg voxels -&gt; mesh. Will be doing GPU side physics to use with noise based particles / fluid simulation at some point. Also GPU only is good for real-time editing.</p>
<p>BTW was using marching cubes for this, but I&rsquo;m still toying with naive surface nets for low end mobile platforms as it&rsquo;s much less ploygon soup when done. Also with naive surface nets you can generate less dense CPU side physics meshes then render on GPU in higher detail.</p>
<p>I also tossed in a preview of a simple 2 texture triplanar &lsquo;cave&rsquo; material for the same shader.</p>
<p><a href="/images/20130907/kagura-0.5.4-0632.png"><img src="/images/20130907/kagura-0.5.4-0632.png" alt="gallery" title="Voxel Terrain - UV Test"></a>
<strong>Voxel Terrain - UV Test</strong></p>
<p><a href="/images/20130907/kagura-0.5.4-0633.png"><img src="/images/20130907/kagura-0.5.4-0633.png" alt="gallery" title="Voxel Terrain - Material"></a>
<strong>Voxel Terrain - Material</strong></p>
<p>Here&rsquo;s the algorithms:</p>
<p><a href="http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html">Chapter 1. Generating Complex Procedural Terrains Using the GPU</a></p>
<p><a href="http://paulbourke.net/geometry/polygonise/">Polygonising a scalar field </a></p>
]]></content>
        </item>
        
    </channel>
</rss>
